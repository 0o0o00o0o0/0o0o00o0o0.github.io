(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{493:function(s,a,n){"use strict";n.r(a);var e=n(4),t=Object(e.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h6",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),n("p",[s._v("无意逛某论坛，看到某位博主当面试官的经历，说是准备一道简单的面试题，可是面试者几乎没有一个答出来的。我看了下。便是如何用 es5 的方式实现一个 const。我也懵逼了，我去面试肯定也是答不出来的。仔细一想不禁觉得这个题目很妙，于是整理一下如何用 es5 实现一个 const 和 let")]),s._v(" "),n("h6",{attrs:{id:"实现-let"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现-let"}},[s._v("#")]),s._v(" 实现 let")]),s._v(" "),n("p",[s._v("let 大家应该用的非常熟悉了，定义一个仅作用于该代码块的变量。首先想到的是去 babel 上面在线转换一下。可是得到的结果竟然是 var。这很不科学，于是我们自己倒腾一下。在 es6 出现以前我们一般使用无限接近闭包的形式或者立即执行函数的形式来定义不会被污染的变量。我们这也可以做类似的操作。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("(function(){var a = 1;console.log(a)})();console.log(a)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("p",[s._v("效果不错，这大概也是使用 es6 的方便之处吧。")]),s._v(" "),n("h6",{attrs:{id:"实现-const"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现-const"}},[s._v("#")]),s._v(" 实现 const")]),s._v(" "),n("p",[s._v("进入这次的主题，const 该怎么实现呢？const 声明一个只读的常量。一旦声明，常量的值就不能改变。有什么方法是可以限制一个值不能发生改变的呢？是的,需要用到 Object.defineProperty。其中有一个属性是这样的。writable：当前对象元素的值是否可修改。于是一切都好说的.于 ES5 环境没有 block 的概念，所以是无法百分百实现 const，只能是挂载到某个对象下，要么是全局的 window，要么就是自定义一个 object 来当容器")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("var __const = function __const(data, value) {\n  window.data = value // 把要定义的data挂载到window下，并赋值value\n  Object.defineProperty(window, data, { // 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符\n    enumerable: false,\n    configurable: false,\n    get: function () {\n      return value\n    },\n    set: function (data) {\n      if (data !== value) { // 当要对当前属性进行赋值时，则抛出错误！\n        throw new TypeError('Assignment to constant variable.')\n      } else {\n        return value\n      }\n    }\n  })\n}\n__const('a', 10)\nconsole.log(a)\ndelete a\nconsole.log(a)\nfor (let item in window) { // 因为const定义的属性在global下也是不存在的，所以用到了enumerable: false来模拟这一功能\n  if (item === 'a') { // 因为不可枚举，所以不执行\n    console.log(window[item])\n  }\n}\na = 20 // 报错\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br")])]),n("p",[s._v("代码有点略长，但是还算通透。那。。还有没有更简单一点的实现方法呢？至少不要这么长的代码demo了。答案是肯定的，只不过没有上面例子那么透彻。我们这次将用到es5的Object.freeze();")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("var f = Object.freeze({'name':'admin'});\nf.name = 'hello'; // 严格模式下是会报错的\nf.name; // 打印出admin ,值没有被改变\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("想要的效果还是出来了，可以大概的定义一个常量了。那么一个新的问题来了，const 真的定义的一定是一个常量嘛？一定是不可变的嘛？我们看看代码的结果")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("const a ={};\na.name='admin';\na.name // admin;\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。")]),s._v(" "),n("h6",{attrs:{id:"带来的新特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#带来的新特性"}},[s._v("#")]),s._v(" 带来的新特性")]),s._v(" "),n("p",[s._v("let,const问世之前，js是没有块级作用域这种特性的，只有函数作用域，导致了很多稀奇古怪的bug。这里就要理解两个的区别，函数作用域好理解，就是函数{}包裹的区域，其实这里使用var，let，const都一样，外部是不能调用函数内部的变量的。但是块级就有区别了，最明显的就是if(){}。在函数内使用条件判断，花括号内使用let,const,那么条件外是访问不到条件内的变量的，代码就会更清晰一点。\n,")]),s._v(" "),n("h6",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),n("p",[s._v("生活中真的很少看到这种清新的题目，发生在身边却从来没有注意到。或许这就是别人为什么是大牛，而我还在这里写着业务代码的原因吧。善于思考与发挥，然后总结于身，这就是我们现在都缺失的吧。。")])])}),[],!1,null,null,null);a.default=t.exports}}]);